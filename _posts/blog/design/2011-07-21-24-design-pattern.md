---
title: 24种设计模式
category: 程序设计
tags: [设计模式]
---

1. 策略模式

    定义一个统一的策略接口，由不同的子类去实现这些策略，再定义一个策略的执行类，去执行策略。

2. 代理模式

    大家都实现同一个接口，作为代理，自己不做事，而是将事交给兄弟类去完成。

3. 单例模式

    将构造函数私有化，满足无论何时，获得的对象都是同一个对象。（需注意多线程问题）

4. 多例模式

    构造函数私有化，可以获得指定个数的实例。


5. 工厂模式

    由一个工厂类负责实现了某个接口的类，使用者不需要知道这些类的创建细节。如三种不同颜色的人种即可使用工厂类来创建。

6. 抽象工厂模式

    在工厂模式的基础上再次抽象，还是造人的例子，如果用工厂模式来定义性别，那么无论是男人还是女人都需要将多有的接口实现一变，但除性别外其实都一样，所以这时应该将除性别外的再次抽象出来，具体的男人、女人只需要实现性别接口。对应的工厂类也是如此，由一个抽象工厂统一创建人，而由具体的实现类去创建男人和女人。

7. 门面模式

    对于某些工作，必须按照既定步骤去完成，步骤不能少，而且顺序也不能乱，做一次到没什么，但要是多次就麻烦了，所以应将这些执行步骤再次封装，新加入的类就是一个门面。

8. 适配器模式

    同样是存取用户信息，但不同的人写出来的接口可以是不同的，为了统一，没必要修改现有的代码，执行增加一个适配器采用继承、实现或者对象应用的方式将一种接口转换为另一种接口……同样，考虑到程序的可扩展性，也可以适当的使用该模式。（可以同电源适配器类比）

9. 模板方法模式

    在模板类中定义一个方法去执行具有特定顺序的方法，但这些方法都需要具体子类去实现。（父类调用子类的方法）

10. 建造者模式

    与工厂模式类似，但工厂模式注重的创建对象，而建造者模式注重的是组装（按特定步骤执行一系列操作）

11. 桥梁模式

    两个类之间存在引用，为了解耦合，应在二者之间建立一个桥梁，从而上方都是可扩展的，且不影响另一方。（将引用改为依赖抽象）

12. 命令模式

    对于同一件事，由谁来做，怎么做都有着各种各样的情况，但对于客户来说，他是发出命令和得到结果，其它一概不关心，所以提供一个接口人来接受客户的命令，再将任务分派给特定的执行者去执行，然后将结果返回给客户。有点类似代理模式，但这个接口人什么也不会做……和策略模式相比，命令模式需要多个具体的执行类去完成多个特定的动作……

13. 装饰模式

    在原有的基础上加壳，是对继承的一种扩展……

14. 迭代器模式

    换一种方式遍历集合中的元素。（java.util.Iterable）

15. 组合模式

    树形结构的存储……

16. 观察者模式

    当被观察者（java.util.Observable）有某种行为时，立即通知部分或所有观察者（java.util.Observer）。用于事件监听器和消息通知的实现。

17. 责任链模式

    对于客户端发出的某个请求，需要由某个特定的执行者来处理，执行者可以有多个，但对于一个请求只能由一个执行者处理，对于某个请求应该由谁来处理呢？为了将判断从客户端移除（满足迪米特法则），应该将所有执行者串联起来，如果能处理，则该请求处理结束，否则交个下一个执行者处理或者忽略该请求。对于客户端，不知道也不关心请求是谁处理的，只需关心请求有没有被处理，处理结果是什么。

    与观察者模式相比该模式的传播方式是1：1的，且有且仅有一个执行者执行处理，传递的信息也不得有任何改变。而观察者模式的传播方式可以是1：N的，对同一个信息将广播给多个观察者，且信息可以改变。

18. 访问者模式

    与观察者模式类似，但该模式是将对象本身交个一个或者多个访问者，访问者接受到对象后做出相应操作，访问者不一定立即做出响应（客户端）。多用于统计、报表等，拦截器的实现可参照该模式。对于观察者模式，当触发某个事件时，仅仅是通知所有观察者该对象在做什么，该执行的动作继续执行。而访问者模式是将对象本身完全交个访问者，访问者将这些信息收集由于统计等，同时还可以对被访问者产生影响（拦截器）。

19. 状态模式

    多个状态可以相互切换，但状态间的切换必须满足必要的前提条件。在上下文中定义所有状态，并提供状态切换接口和所有可执行的所有操作，但这些操作都交个当前状态去执行。各个状态只处理当天状态需要执行的动作，对于其它动作，如果允许状态切换，则切换状态后将该动作委托给对应的状态去执行。（电梯）

20. 原型模式

    不通过new 关键字来产生一个对象，而是通过对象拷贝来实现的模式就叫做原型模式。需要注意的是：

    1. 需要拷贝的对象必须实现Cloneable接口，重写clone方法；
    2. 对象拷贝时，类的构造函数是不会被执行的。
    3. 浅拷贝和深拷贝问题。
    4. Clone与final两对冤家。

21. 中介模式

    N个类（N>2的同事类）之间存在相互依赖关系，如果这种依赖关系太过复杂，应有一个中介者来负责管理这些同事类，并负责调度跨同事类的操作。每个同事类应将中介者作为构造函数参数传入，一旦涉及需要某些同事类来处理的动作，都应交个中介去调度。

22. 解释器模式

    语法解析（四则原算）

23. 享元模式

    抽取共有属性最为外部对象进行存储。

24. 备忘录模式

    保存对象的某些状态，并可以在需要的时候恢复。
